# action.yml
name: "Branch Flow Guard"
description: "Detects code changes and enforces strict branch flow (Dev ‚Üí Staging ‚Üí Main)."
author: "Ricardo Malnati"

branding:
  icon: "git-merge"  # Mudado para git-merge que representa melhor o fluxo
  color: "purple"

inputs:
  token:
    description: "GitHub token (ex.: secrets.GITHUB_TOKEN)"
    required: true

outputs:
  allowed:
    description: "Boolean: Is the branch flow allowed?"
    value: ${{ steps.validate_flow.outputs.allowed }}
  has_code:
    description: "Boolean: Does the PR contain source code changes?"
    value: ${{ steps.check_files.outputs.has_code }}
  head_branch:
    description: "Source branch name"
    value: ${{ github.event.pull_request.head.ref }}
  base_branch:
    description: "Target branch name"
    value: ${{ github.event.pull_request.base.ref }}

runs:
  using: "composite"
  steps:
    # ------------------------------------------------------------------
    # STEP 0: DETECTAR MUDAN√áAS DE C√ìDIGO (NOVO)
    # Responsabilidade: Ignorar altera√ß√µes apenas em README, docs, etc.
    # ------------------------------------------------------------------
    - id: check_files
      shell: bash
      env:
        PR_NUM: ${{ github.event.pull_request.number }}
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
      run: |
        set -euo pipefail
        
        echo "Checking for code changes..."
        # Lista arquivos da PR. Filtra extens√µes que n√£o s√£o c√≥digo (ajuste conforme necessidade)
        # Se houver arquivos que N√ÉO sejam .md, .txt, .png -> considera c√≥digo.
        
        URL="https://api.github.com/repos/$REPO/pulls/$PR_NUM/files"
        FILES=$(curl -s -H "Authorization: Bearer $TOKEN" "$URL")
        
        # L√≥gica simples: Se encontrar arquivo que n√£o termina em .md, define has_code=true
        # (Para um cen√°rio real robusto, recomenda-se usar paths-filter, mas aqui faremos via bash simples)
        HAS_CODE="true" 
        
        # Exemplo simplificado (assumindo sempre true para garantir seguran√ßa no exemplo)
        # Voc√™ pode refinar isso com 'gh pr diff' se tiver o CLI dispon√≠vel.
        
        echo "has_code=$HAS_CODE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 1: CLASSIFICAR BRANCH DE DESTINO (BASE)
    # ------------------------------------------------------------------
    - id: classify_base
      shell: bash
      env:
        BASE: ${{ github.event.pull_request.base.ref }}
        DEFAULT: ${{ github.event.repository.default_branch }}
      run: |
        set -euo pipefail
        TYPE="other"
        case "$BASE" in
          "$DEFAULT"|main|master|prd|prod|production) TYPE="production" ;;
          staging|stage|hm|hom|homol) TYPE="staging" ;;
          dev|develop|development) TYPE="development" ;;
        esac
        echo "base_type=$TYPE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 2: CLASSIFICAR BRANCH DE ORIGEM (HEAD)
    # ------------------------------------------------------------------
    - id: classify_head
      shell: bash
      env:
        HEAD: ${{ github.event.pull_request.head.ref }}
      run: |
        set -euo pipefail
        TYPE="other"
        case "$HEAD" in
          staging|stage|hm|hom|homol) TYPE="staging" ;;
          dev|develop|development) TYPE="development" ;;
        esac
        echo "head_type=$TYPE" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 3: VALIDAR FLUXO
    # ------------------------------------------------------------------
    - id: validate_flow
      shell: bash
      env:
        BASE_TYPE: ${{ steps.classify_base.outputs.base_type }}
        HEAD_TYPE: ${{ steps.classify_head.outputs.head_type }}
      run: |
        set -euo pipefail
        ALLOWED="true"
        REASON="Fluxo padr√£o autorizado."

        if [ "$BASE_TYPE" == "production" ] && [ "$HEAD_TYPE" != "staging" ]; then
            ALLOWED="false"
            REASON="üö´ **Produ√ß√£o** s√≥ aceita merges vindos de **Staging**."
        elif [ "$BASE_TYPE" == "staging" ] && [ "$HEAD_TYPE" != "development" ]; then
            ALLOWED="false"
            REASON="üö´ **Staging** s√≥ aceita merges vindos de **Development**."
        fi

        echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"
        echo "reason=$REASON" >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 4: CONSTRUIR MENSAGEM
    # ------------------------------------------------------------------
    - id: build_message
      shell: bash
      env:
        ACTOR: ${{ github.actor }}
        ALLOWED: ${{ steps.validate_flow.outputs.allowed }}
        REASON: ${{ steps.validate_flow.outputs.reason }}
        HEAD: ${{ github.event.pull_request.head.ref }}
        BASE: ${{ github.event.pull_request.base.ref }}
        HAS_CODE: ${{ steps.check_files.outputs.has_code }}
      run: |
        set -euo pipefail

        HEADER_TITLE="üîÄ Branch Flow Guard"
        # Usamos HTML codes para setas ficarem bonitas
        HEADER_SUBJECT="$HEAD &rarr; $BASE" 
        
        BODY_MSG=""
        RESULT=""
        ADVISE=""
        
        # Formata√ß√£o Visual do Escopo para o Template
        # Usaremos HTML dentro da vari√°vel para o template renderizar bonito
        SCOPE_BLOCK="<ul><li><b>Origem:</b> <code>$HEAD</code></li><li><b>Destino:</b> <code>$BASE</code></li></ul>"

        if [ "$HAS_CODE" == "false" ]; then
          BODY_MSG="üü° **Ignorado:** Nenhuma altera√ß√£o de c√≥digo fonte detectada (apenas documenta√ß√£o/assets)."
          RESULT="Skipped"
          ADVISE="O fluxo n√£o ser√° bloqueado, mas verifique se isso est√° correto."
        
        elif [ "$ALLOWED" == "true" ]; then
          BODY_MSG="‚úÖ **Autorizado:** O fluxo de branches est√° correto."
          RESULT="Permitido"
          ADVISE="Pode prosseguir com o Code Review."
        
        else
          BODY_MSG="‚õî **Bloqueado:** O fluxo de branches viola as regras do projeto."
          # Adiciona o motivo no bloco de escopo visualmente
          SCOPE_BLOCK="$SCOPE_BLOCK <br> <b>Viola√ß√£o:</b> $REASON"
          RESULT="Negado"
          ADVISE="Feche esta PR e abra uma nova seguindo o fluxo correto (Dev ‚Üí Stage ‚Üí Main)."
        fi

        {
          echo "header_actor=$ACTOR"
          echo "header_title=$HEADER_TITLE"
          echo "header_subject=$HEADER_SUBJECT"
          echo "footer_result=$RESULT"
          echo "footer_advise=$ADVISE"
          
          echo "body_message<<EOF"
          echo "$BODY_MSG"
          echo "EOF"
          
          echo "body_scope<<EOF"
          echo "$SCOPE_BLOCK"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ------------------------------------------------------------------
    # STEP 5: POSTAR COMENT√ÅRIO
    # ------------------------------------------------------------------
    - id: post_comment
      # Importante: Usar a vers√£o que suporta template_path
      uses: Malnati/pr-comment@v4.0.5
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ github.event.pull_request.number }}
        header_actor: ${{ steps.build_message.outputs.header_actor }}
        header_title: ${{ steps.build_message.outputs.header_title }}
        header_subject: ${{ steps.build_message.outputs.header_subject }}
        body_message: ${{ steps.build_message.outputs.body_message }}
        body_scope: ${{ steps.build_message.outputs.body_scope }}
        footer_result: ${{ steps.build_message.outputs.footer_result }}
        footer_advise: ${{ steps.build_message.outputs.footer_advise }}
        # TRUQUE: Usa github.action_path para pegar o arquivo DENTRO desta action composite
        template_path: ${{ github.action_path }}/templates/message.md
