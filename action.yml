# action.yml
name: "Branch Flow Detector"
description: "Detects code changes in a Pull Request and validates the branch flow (dev ‚Üí staging ‚Üí main)."
author: "Ricardo Malnati"

branding:
  icon: "git-branch"
  color: "purple"

inputs:
  token:
    description: "GitHub token (ex.: secrets.GITHUB_TOKEN)"
    required: true

outputs:
  has_code:
    description: "Indica se a PR cont√©m altera√ß√µes de c√≥digo"
    value: ${{ steps.detect_code.outputs.has_code }}
  allowed:
    description: "Indica se o fluxo de branches √© permitido"
    value: ${{ steps.validate_flow.outputs.allowed }}
  head_branch:
    description: "Nome da branch de origem"
    value: ${{ github.event.pull_request.head.ref }}
  base_branch:
    description: "Nome da branch de destino"
    value: ${{ github.event.pull_request.base.ref }}

runs:
  using: "composite"
  steps:
    # ========================================================================
    # STEP 1: DETEC√á√ÉO DE ARQUIVOS DE C√ìDIGO
    # Responsabilidade: Iterar sobre arquivos do PR e flagrar extens√µes de c√≥digo
    # ========================================================================
    - id: detect_code
      shell: bash
      env:
        TOKEN: ${{ inputs.token }}
        REPO: ${{ github.repository }}
        PR_NUM: ${{ github.event.pull_request.number }}
        # Extens√µes definidas como vari√°vel de ambiente para f√°cil manuten√ß√£o
        CODE_EXTENSIONS: ".js .jsx .ts .tsx .java .kt .kts .py .rb .go .php .cs .c .cpp .h .hpp .rs .swift .sql .sh .bash .ps1"
      run: |
        set -euo pipefail

        PER_PAGE=100
        PAGE=1
        HAS_CODE="false"
        API_URL="https://api.github.com/repos/$REPO/pulls/$PR_NUM/files"

        echo "Iniciando verifica√ß√£o de arquivos na PR #$PR_NUM..."

        while :; do
          # Busca paginada de arquivos
          RESP="$(curl -sS -H "Authorization: Bearer $TOKEN" \
                           -H "Accept: application/vnd.github+json" \
                           "$API_URL?per_page=$PER_PAGE&page=$PAGE")"

          # Conta arquivos na p√°gina atual
          COUNT="$(echo "$RESP" | jq 'length')"

          if [ "$COUNT" -eq 0 ]; then
            break
          fi

          # Extrai lista de nomes de arquivos
          FILENAMES="$(echo "$RESP" | jq -r '.[].filename')"

          # Itera sobre os arquivos encontrados
          while IFS= read -r FILE; do
            if [ -z "$FILE" ]; then continue; fi
            
            for EXT in $CODE_EXTENSIONS; do
              # Verifica se o arquivo termina com a extens√£o (glob matching)
              if [[ "$FILE" == *"$EXT" ]]; then
                echo "C√≥digo detectado: $FILE matches $EXT"
                HAS_CODE="true"
                break 3 # Sai dos dois loops (for e while interno) e do while principal
              fi
            done
          done <<< "$FILENAMES"

          if [ "$COUNT" -lt "$PER_PAGE" ]; then
            break
          fi
          
          PAGE=$((PAGE + 1))
        done

        echo "has_code=$HAS_CODE" >> "$GITHUB_OUTPUT"

    # ========================================================================
    # STEP 2: CLASSIFICAR BRANCH DE DESTINO (BASE)
    # Responsabilidade: Identificar se o alvo √© Prod, Stage ou Dev
    # ========================================================================
    - id: classify_base
      shell: bash
      env:
        BASE: ${{ github.event.pull_request.base.ref }}
        DEFAULT: ${{ github.event.repository.default_branch }}
      run: |
        set -euo pipefail
        
        TYPE="other"
        
        # Normaliza lista de branches conhecidas
        case "$BASE" in
          "$DEFAULT"|main|master|prd|prod|production|producao)
            TYPE="production"
            ;;
          staging|stage|hm|hom|homol|homolog|homologation|homologacao)
            TYPE="staging"
            ;;
          dev|develop|development)
            TYPE="development"
            ;;
        esac
        
        echo "base_type=$TYPE" >> "$GITHUB_OUTPUT"

    # ========================================================================
    # STEP 3: CLASSIFICAR BRANCH DE ORIGEM (HEAD)
    # Responsabilidade: Identificar se a origem √© Stage ou Dev
    # ========================================================================
    - id: classify_head
      shell: bash
      env:
        HEAD: ${{ github.event.pull_request.head.ref }}
      run: |
        set -euo pipefail
        
        TYPE="other"
        
        case "$HEAD" in
          staging|stage|hm|hom|homol|homolog|homologation|homologacao)
            TYPE="staging"
            ;;
          dev|develop|development)
            TYPE="development"
            ;;
        esac
        
        echo "head_type=$TYPE" >> "$GITHUB_OUTPUT"

    # ========================================================================
    # STEP 4: VALIDAR FLUXO (REGRA DE NEG√ìCIO)
    # Responsabilidade: Cruzar Base vs Head e definir 'Allowed'
    # ========================================================================
    - id: validate_flow
      shell: bash
      env:
        BASE_TYPE: ${{ steps.classify_base.outputs.base_type }}
        HEAD_TYPE: ${{ steps.classify_head.outputs.head_type }}
      run: |
        set -euo pipefail
        
        ALLOWED="true"
        REASON="Fluxo padr√£o"

        if [ "$BASE_TYPE" == "production" ]; then
          # Para ir para Prod, a origem DEVE ser Staging
          if [ "$HEAD_TYPE" != "staging" ]; then
            ALLOWED="false"
            REASON="Envio para Produ√ß√£o permitido apenas via Staging."
          fi
        elif [ "$BASE_TYPE" == "staging" ]; then
          # Para ir para Staging, a origem DEVE ser Development
          if [ "$HEAD_TYPE" != "development" ]; then
            ALLOWED="false"
            REASON="Envio para Staging permitido apenas via Development."
          fi
        fi

        echo "allowed=$ALLOWED" >> "$GITHUB_OUTPUT"
        echo "reason=$REASON" >> "$GITHUB_OUTPUT"

    # ========================================================================
    # STEP 5: CONSTRUIR MENSAGEM
    # Responsabilidade: Montar texto do coment√°rio baseado nos resultados anteriores
    # ========================================================================
    - id: build_message
      shell: bash
      env:
        ACTOR: ${{ github.actor }}
        HAS_CODE: ${{ steps.detect_code.outputs.has_code }}
        ALLOWED: ${{ steps.validate_flow.outputs.allowed }}
        REASON: ${{ steps.validate_flow.outputs.reason }}
        HEAD: ${{ github.event.pull_request.head.ref }}
        BASE: ${{ github.event.pull_request.base.ref }}
        DEFAULT: ${{ github.event.repository.default_branch }}
      run: |
        set -euo pipefail

        HEADER_TITLE="üîÄ flow-check"
        HEADER_SUBJECT="Fluxo de branches e altera√ß√µes de c√≥digo"
        
        BODY_MSG=""
        RESULT=""
        ADVISE=""
        
        # Constr√≥i o bloco de escopo (Metadata)
        SCOPE_BLOCK="- head: \`$HEAD\`
        - base: \`$BASE\`
        - default: \`$DEFAULT\`
        - has_code: \`$HAS_CODE\`
        - allowed: \`$ALLOWED\`"

        if [ "$HAS_CODE" == "false" ]; then
          # Caso 1: Sem c√≥digo (apenas docs, imagens, etc)
          BODY_MSG="üü° Nenhuma altera√ß√£o de c√≥digo fonte detectada."
          RESULT="Nenhuma altera√ß√£o de c√≥digo."
          ADVISE="O fluxo de branches n√£o ser√° bloqueado, mas outras valida√ß√µes podem se aplicar."
        
        elif [ "$ALLOWED" == "true" ]; then
          # Caso 2: Tem c√≥digo e Fluxo Correto
          BODY_MSG="‚úÖ Fluxo de branches **permitido** e altera√ß√µes de c√≥digo detectadas."
          RESULT="Fluxo permitido."
          ADVISE="Continue com as valida√ß√µes e revis√µes habituais."
        
        else
          # Caso 3: Tem c√≥digo e Fluxo Incorreto
          BODY_MSG="‚õî Fluxo de branches **n√£o permitido** para esta Pull Request."
          SCOPE_BLOCK="$SCOPE_BLOCK
        - reason: $REASON
        - rule: dev ‚Üí staging ‚Üí main"
          RESULT="Fluxo inv√°lido."
          ADVISE="Ajuste a origem/destino para respeitar o fluxo dev ‚Üí staging ‚Üí main."
        fi

        {
          echo "header_actor=$ACTOR"
          echo "header_title=$HEADER_TITLE"
          echo "header_subject=$HEADER_SUBJECT"
          echo "footer_result=$RESULT"
          echo "footer_advise=$ADVISE"
          
          # Multiline outputs
          echo "body_message<<EOF"
          echo "$BODY_MSG"
          echo "EOF"
          
          echo "body_scope<<EOF"
          echo "$SCOPE_BLOCK"
          echo "EOF"
        } >> "$GITHUB_OUTPUT"

    # ========================================================================
    # STEP 6: POSTAR COMENT√ÅRIO
    # ========================================================================
    - id: post_comment
      uses: Malnati/pr-comment@v4
      with:
        token: ${{ inputs.token }}
        pr_number: ${{ github.event.pull_request.number }}
        header_actor: ${{ steps.build_message.outputs.header_actor }}
        header_title: ${{ steps.build_message.outputs.header_title }}
        header_subject: ${{ steps.build_message.outputs.header_subject }}
        body_message: ${{ steps.build_message.outputs.body_message }}
        body_scope: ${{ steps.build_message.outputs.body_scope }}
        body_todo: "" # N√£o utilizado nesta action
        footer_result: ${{ steps.build_message.outputs.footer_result }}
        footer_advise: ${{ steps.build_message.outputs.footer_advise }}
